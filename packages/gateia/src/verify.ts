import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';
import { 
    VerifyParams, 
    VerifyResult, 
    GateiaError, 
    Policy, 
    EnforcementReport, 
    AppliedPolicyRec, 
    PolicyAction, 
    GateOutcome 
} from './types';
import { ContractEngine } from './engine/contract';
import { PolicyEngine } from './engine/policy';
import { policyLibrary } from './policies';

const contractEngine = new ContractEngine();
const policyEngine = new PolicyEngine();

export async function verify<T extends z.ZodTypeAny>(params: VerifyParams<T>): Promise<VerifyResult<z.infer<T>>> {
    const traceId = uuidv4();
    const { output, contract, policies = [], mode = 'enforce' } = params;

    try {
        // --- 1. Contract Validation ---
        // (If output is string and contract is Object, we might want to try parsing it? 
        //  The pivot request says "Gateia works with outputs generated by ANY provider".
        //  Users might pass raw JSON string. Should we auto-parse? 
        //  For now, assume user handles parsing OR we do simple string->object if schema demands it.)
        
        let outputToValidate = output;
        
        // Auto-parse JSON string if schema is object/array but output is string
        if (typeof output === 'string' && (contract instanceof z.ZodObject || contract instanceof z.ZodArray)) {
            try {
                // 1. Try to extract from markdown code blocks
                const jsonBlockMatch = output.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
                if (jsonBlockMatch && jsonBlockMatch[1]) {
                    outputToValidate = JSON.parse(jsonBlockMatch[1].trim());
                } else {
                    // 2. Try parsing the raw string (maybe it's just JSON)
                    outputToValidate = JSON.parse(output.trim());
                }
            } catch (e) {
                // Failed to parse, validation will likely fail next
            }
        }

        const contractRes = contractEngine.validate(outputToValidate, contract);
        
        let safeOutput = contractRes.success ? contractRes.data : undefined;
        const contractErrors = contractRes.success ? undefined : contractRes.errors;
        const contractOutcome = contractRes.success ? 'pass' : 'fail';

        // --- 2. Policy Enforcement ---
        // Resolve policies
        const activePolicies: Policy<any>[] = policies.map(p => {
          if (typeof p === 'string') {
            const found = policyLibrary[p];
            if (!found) throw new GateiaError(`Unknown policy: ${p}`, traceId);
            return found;
          }
          return p;
        });

        // Run policies
        // Note: We run policies on the *safeOutput* if valid, or original *output* if not?
        // Ideally we check specific fields if valid. If invalid, we might still check the raw string?
        // Let's run on `currentOutput` which is `safeOutput` ?? `output`.
        const contentToCheck = safeOutput !== undefined ? safeOutput : output;
        
        const policyCtx = { traceId };
        const policyResult = await policyEngine.evaluate(activePolicies, contentToCheck, policyCtx);

        let finalViolations = policyResult.violations || [];
        let enforcementActions: PolicyAction[] = [];

        // Apply Rewrites if allowed
        if (policyResult.rewrittenOutput) {
            safeOutput = policyResult.rewrittenOutput;
            enforcementActions.push({ type: 'rewrite', policyId: 'policy-engine', note: 'Content rewritten' });
        }

        // Build Applied Report
        const appliedRecs: AppliedPolicyRec[] = activePolicies.map(p => {
            const pViolations = finalViolations.filter(v => v.policyId === p.id);
            let outcome: GateOutcome = 'pass';
            if (pViolations.length > 0) {
                const isBlock = pViolations.some(v => v.severity === 'high'); 
                outcome = isBlock ? 'block' : 'warn'; 
            }
            return { 
                id: p.id, 
                version: p.version,
                mode: p.mode || 'enforce',
                outcome,
                reasons: pViolations.map(v => v.message)
            };
        });

        // --- 3. Decision ---
        // BLOCK if: 
        // 1. Contract Failed (Invalid structure)
        // 2. Any High Severity Violation (unless mode=audit)
        
        const contractFailed = !contractRes.success;
        // Check both explicit violations AND the aggregated outcome from policy engine
        // This handles cases where a user returns { outcome: 'block' } but omits violations
        const blockedByPolicy = finalViolations.some(v => v.severity === 'high') || 
                                (policyResult.outcome === 'block' && mode === 'enforce');
        
        // Safety Fallback: If blocked but no violations, inject one for reporting
        if (blockedByPolicy && finalViolations.length === 0) {
            finalViolations.push({
                policyId: 'gateia-core',
                code: 'IMPLICIT_BLOCK',
                message: 'A policy returned BLOCK status but provided no violation details.',
                severity: 'high'
            });
        }
        
        let allowed = true;
        
        if (contractFailed) allowed = false;
        if (blockedByPolicy && mode === 'enforce') allowed = false;

        const report: EnforcementReport = {
            appliedPolicies: appliedRecs,
            contract: {
                outcome: contractOutcome,
                errors: contractErrors
            },
            actions: enforcementActions,
            violations: finalViolations
        };

        return {
            allowed,
            safeOutput: allowed ? safeOutput : undefined,
            traceId,
            enforcement: report,
            rawOutput: params.options?.includeRawOutput ? output : undefined
        };

    } catch (error) {
         if (error instanceof GateiaError) throw error;
         throw new GateiaError((error as Error).message, traceId, undefined, error);
    }
}
